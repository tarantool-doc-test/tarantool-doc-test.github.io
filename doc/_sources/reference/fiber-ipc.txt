-------------------------------------------------------------------------------
                                 Package `fiber-ipc`
-------------------------------------------------------------------------------

Пакет ``fiber-ipc`` позволяет разным процессам взаимодействовать путем отсылки
и приема сообщений. Здесь под "разными процессами" подразумеваются разные
соединения, разные сессии или разные файберы.

Вызовите функцию ``fiber.channel()``, чтобы создать объект типа канал. Далее в
этом разделе мы будем называть этот объект каналом. Затем вызывайте для этого
канала другие функции из пакета ``fiber-ipc``, чтобы отсылать сообщения, принимать
сообщения или проверять статус канала. Обмен сообщениями происходит в
синхронном режиме. Если канал никем не используется, он уничтожается сборщиком
мусора, как это происходит с любым Lua-объектом. Используйте 
объектно-ориентированный синтаксис, например, ``channel:put(message)``
вместо ``fiber.channel.put(message)``.

.. module:: fiber

.. function:: channel([capacity])

    Создает новый канал для обмена сообщениями.

    :param int capacity: количество слотов в канале для хранения отсылаемых
                         сообщений (положительное целое число). Определяет 
                         максимальное количество сообщений, которые могут 
                         храниться в канале.

    :return: новый канал.
    :rtype:  userdata

.. class:: channel_object

    .. method:: put(message[, timeout])

        Отсылает сообщение, используя указанный канал. Если канал полон
        (все слоты заполнены), ждет, пока в канале не появится свободный слот.

        :param lua_object message: сообщение для отсылки.
        :param timeout: максимальное время ожидания появления свободного слота
                        в канале (в секундах); если параметр не задан, ожидание
                        выполняется бесконечно.
        :return: false -- если задано время ожидания и в канале не появляется
		 свободный слот в течение этого периода времени. true -- в
		 противном случае.
        :rtype:  boolean

    .. method:: close()

        Закрывает канал. Все вызовы функций на данном канале, которые находятся
        в состоянии ожидания, будут разблокированы. Все последующие вызовы функций
        ``channel:put()`` и ``channel:get()`` вернут ошибку (``nil``).

    .. method:: get([timeout])

        Извлекает сообщение из канала. Если канал пуст (в канале нет сообщений),
        ждет прихода сообщения.

        :param timeout: максимальное время ожидания прихода сообщения (в секундах);
                        если параметр не задан, ожидание выполняется бесконечно.
        :return: сообщение, ранее помещенное в канал вызовом функции
                 ``channel:put()``.
        :rtype:  lua_object

    .. method:: is_empty()

        Проверяет, является ли канал пустым (т.е. в канале отсутствуют сообщения).
        
        :return: true -- если канал пуст. false -- в противном случае.
        :rtype:  boolean

    .. method:: count()

        Подсчитывает количество сообщений в канале.

        :return: количество сообщений в канале (ноль, если канал пуст).
        :rtype:  number

    .. method:: is_full()

        Проверяет, является ли канал полным (т.е. в канале нет места для новых сообщений).

	:return: true -- если канал полон. false -- в противном случае.
        :rtype:  boolean

    .. method:: has_readers()

        Проверяет, является ли канал пустым, и есть ли при этом пользователи, которые ранее
        вызвали функцию ``channel:get()`` и теперь ждут сообщений из канала.

	:return: true -- если есть пользователи, ждущие сообщений из канала.
	         false -- в противном случае.
        :rtype:  boolean

    .. method:: has_writers()

        Проверяет, является ли канал полным, и есть ли при этом пользователи, которые ранее
        вызвали функцию ``channel:put()`` и теперь ждут, когда в канале освободится место 
        для новых сообщений.

	:return: true -- если есть пользователи, ждущие, когда в канале
		 освободится место для новых сообщений. false -- в противном
		 случае.
        :rtype:  boolean

    .. method:: is_closed()

        Проверяет, закрыт ли указанный канал.
    
	:return: true -- если канал закрыт. false -- в противном случае.
        :rtype:  boolean

=================================================
                    Example
=================================================

.. code-block:: lua

    fiber = require('fiber')
    channel = fiber.channel(10)
    function consumer_fiber()
        while true do
            local task = channel:get()
            ...
        end
    end

    function consumer2_fiber()
        while true do
            -- 10 секунд
            local task = channel:get(10)
            if task ~= nil then
                ...
            else
                -- timeout
            end
        end
    end

    function producer_fiber()
        while true do
            task = box.space...:select{...}
            ...
            if channel:is_empty() then
                -- канал пуст
            end

            if channel:is_full() then
                -- канал полон
            end

            ...
            if channel:has_readers() then
                -- есть файберы, которые
                -- ждут данные из канала
            end
            ...

            if channel:has_writers() then
                -- есть файберы, которые ждут,
                -- что кто-то прочтет данные из канала
            end
            channel:put(task)
        end
    end

    function producer2_fiber()
        while true do
            task = box.space...select{...}
            -- 10 секунд
            if channel:put(task, 10) then
                ...
            else
                -- timeout
            end
        end
    end
